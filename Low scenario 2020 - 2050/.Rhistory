choice="var"
ggtheme = theme_minimal()
fviz_mca_var(res.mca1, axes=c(3,4),col.var = "contrib",
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
repel = TRUE, # avoid text overlapping (slow)
choice="var",
ggtheme = theme_minimal()
)
fviz_mca_var(res.mca1, axes=c(3,4),
repel = TRUE, # avoid text overlapping (slow)
choice="var",
ggtheme = theme_minimal()
)
fviz_mca_var(res.mca1, axes=c(1,3),col.var = "contrib",
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
repel = TRUE, # avoid text overlapping (slow)
ggtheme = theme_minimal()
)
fviz_mca_var(res.mca1, axes=c(1,3),
repel = TRUE, # avoid text overlapping (slow)
choice="var",
ggtheme = theme_minimal()
)
fviz_mca_var(res.mca1, axes=c(1,3),col.var = "contrib",
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
repel = TRUE, # avoid text overlapping (slow)
ggtheme = theme_minimal()
)
fviz_mca_var(res.mca1,col.var = "contrib",
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
repel = TRUE, # avoid text overlapping (slow)
ggtheme = theme_minimal()
)
fviz_mca_var(res.mca1, axes=c(1,3),
repel = TRUE, # avoid text overlapping (slow)
choice="var",
ggtheme = theme_minimal()
)
# install.packages("nycflights13")
# install.packages("dlookr")
library(nycflights13)
library(dlookr)
library(ggplot2)
library(FactoMineR)
library(factoextra)
# Utilizando el conjunto de datos conocido flights
data(flights)
# View(flights)
head(flights)
# Resumen estadístico de las variables numéricas
summary(flights)
ggplot(flights, aes(x = dep_delay)) +
geom_histogram(binwidth = 10, fill = "blue") +
labs(title = "Histograma de Departure Delay",
x = "Retraso en la Salida (minutos)",
y = "Frecuencia")
# Diagrama de caja para "arr_delay" vs. "carrier"
ggplot(flights, aes(x = carrier, y = arr_delay)) +
geom_boxplot(fill = "blue") +
labs(title = "Boxplot de Arrival Delay por Carrier",
x = "Carrier",
y = "Retraso en la Llegada (minutos)")
# Diagrama de caja para "dep_delay" vs. "carrier"
ggplot(flights, aes(x = carrier, y = dep_delay)) +
geom_boxplot(fill = "blue") +
labs(title = "Boxplot de Dep Delay por Carrier",
x = "Carrier",
y = "Retraso en la Salida (minutos)")
# Gráfico de dispersión entre "distance" y "air_time"
ggplot(flights, aes(x = distance, y = air_time)) +
geom_point(color = "blue") +
labs(title = "Gráfico de Dispersión entre Distance y Air Time",
x = "Distancia (millas)",
y = "Tiempo en el Aire (minutos)")
# Mostramos el número de valores faltantes por variable
colSums(is.na(flights))
# Transformar las variables categóricas en indicadores
indicator_matrix <- model.matrix(~ carrier - 1, data = flights)
# Combinar las variables indicadoras con dep_delay y arr_delay
data_for_acp <- cbind(indicator_matrix, flights$dep_delay, flights$arr_delay)
# Realizar el ACP
acp_result <- PCA(data_for_acp, scale.unit = TRUE, graph = FALSE)
# Visualizar los resultados
summary(acp_result)
###Aplicación de clasificación jerárquica###
Cong=HCPC(acp_result)
Cong$data.clust
Cong$call$t
IdCong=Cong$data.clust[,5]
IdCong
###Observar la varianza###
CACP=acp_result$ind$coord
CACP
levene.test(CACP[,1],as.factor(IdCong))
fit=aov(CACP[,1]~as.factor(IdCong))
anova(fit)
# Visualizar los resultados
summary(acp_result)
# Cargar las bibliotecas necesarias
library(FactoMineR)
# Seleccionar las variables de interés
variables_de_interes <- c("carrier", "dep_delay", "arr_delay")
# Crear un nuevo conjunto de datos con las variables de interés
data_for_acm <- flights[variables_de_interes]
# Aplicar el Análisis de Componentes Múltiples (ACM)
acm_result <- MCA(data_for_acm, graph = FALSE)
# Visualizar los resultados
summary(acm_result)
# Mostramos el número de valores faltantes por variable
colSums(is.na(flights))
# Imputamos valores faltantes en "arr_delay" con la mediana
flights$arr_delay[is.na(flights$arr_delay)] <- median(flights$arr_delay, na.rm = TRUE)
# Imputamos valores faltantes en "dep_delay" con la mediana
flights$dep_delay[is.na(flights$dep_delay)] <- median(flights$dep_delay, na.rm = TRUE)
# Imputamos valores faltantes en "dep_time" con la mediana
flights$dep_time[is.na(flights$dep_time)] <- median(flights$dep_time, na.rm = TRUE)
# Imputamos valores faltantes en "arr_time" con la mediana
flights$arr_time[is.na(flights$arr_time)] <- median(flights$arr_time, na.rm = TRUE)
# Imputamos valores faltantes en "tailnum" con la moda
flights$tailnum[is.na(flights$tailnum)] <- which.max(table(flights$tailnum))
# Mostrar el número de valores faltantes por variable
colSums(is.na(flights))
# Transformar las variables categóricas en indicadores
indicator_matrix <- model.matrix(~ carrier - 1, data = flights)
# Combinar las variables indicadoras con dep_delay y arr_delay
data_for_acp <- cbind(indicator_matrix, flights$dep_delay, flights$arr_delay)
# Realizar el ACP
acp_result <- PCA(data_for_acp, scale.unit = TRUE, graph = FALSE)
# Visualizar los resultados
summary(acp_result)
library(FactoMineR)
library(party)
library(rminer)
library(lawstat)
library(dplyr)
library(openxlsx) #Librería que interactúa con MSExcel
library(corrplot) #Librería para el gráfico de correlaciones
library(corrr) #Otra opción de librería para el cálculo y gráfico de correlaciones
library(nycflights13)
#datos <- flights
#mydata <- datos[,3:8]
mydata <- iris[,1:4]
library(psych)
KMO(mydata)
cor(mydata)
indicator_matrix
datos <- flights
mydata <- datos[,3:8]
datos <- flights
mydata <- datos[,3:8]
library(psych)
cor(mydata)
KMO(mydata)
cortest.bartlett(mydata)
ev <- eigen(cor(mydata)) # get eigenvalues
ev$values
scree(mydata, pc=FALSE)
fa.parallel(mydata, fa="fa")
scree(mydata, pc=FALSE)
fa.parallel(mydata, fa="fa")
Nfacs <- 2  # This is for four factors. You can change this as needed.
fit <- factanal(mydata, Nfacs, rotation="promax")
print(fit, digits=2, cutoff=0.3, sort=TRUE)
load <- fit$loadings[,1]
load <- fit$loadings[,2]
plot(load,type="n") # set up plot
text(load,labels=names(mydata),cex=.7)
loads <- fit$loadings
fa.diagram(loads)
##########################
AF <- factor(mydata, levels=c(1:2))
fa.diagram(loads)
##########################
AF <- factor(mydata, levels=c(1:2))
AF
table(AF)
datos <- flights
mydata <- datos[,3:8]
library(psych)
cor(mydata)
mydata
cor(mydata)
KMO(mydata)
cortest.bartlett(mydata)
ev <- eigen(cor(mydata)) # get eigenvalues
ev$values
scree(mydata, pc=FALSE)
fa.parallel(mydata, fa="fa")
Nfacs <- 2  # This is for four factors. You can change this as needed.
fit <- factanal(mydata, Nfacs, rotation="promax")
print(fit, digits=2, cutoff=0.3, sort=TRUE)
load <- fit$loadings[,2]
plot(load,type="n") # set up plot
text(load,labels=names(mydata),cex=.7)
loads <- fit$loadings
fa.diagram(loads)
load <- fit$loadings[,2]
plot(load,type="n") # set up plot
text(load,labels=names(mydata),cex=.7)
loads <- fit$loadings
fa.diagram(loads)
##########################
AF <- factor(mydata, levels=c(1:2))
AF
table(AF)
Nfacs <- 3  # This is for four factors. You can change this as needed.
fit <- factanal(mydata, Nfacs, rotation="promax")
print(fit, digits=2, cutoff=0.3, sort=TRUE)
load <- fit$loadings[,3]
plot(load,type="n") # set up plot
text(load,labels=names(mydata),cex=.7)
loads <- fit$loadings
fa.diagram(loads)
library(FactoMineR)
library(party)
library(rminer)
library(lawstat)
###Llamando la base de datos###
data(iris)
View(iris)
names(iris)
###Aplicación del Análisis de Componentes Principales###
ACP=PCA(iris[,1:4],ncp=2)
###Aplicación de clasificación jerárquica###
Cong=HCPC(ACP)
knitr::opts_chunk$set(echo = TRUE)
install.packages("pdflatex")
setwd("C:/Users/camil/Documents/2023-2/AMTV")
setwd("~/2023-2/AMTV/project")
dir
ls
data <- read.csv("szbv-lu-2020-2050-tief.csv")
head(data)
# Resumen estadístico de whisky
summary(data)
# Contar datos faltantes por variable
sum(is.na(data))
data <- read.csv("szbv-lu-2020-2050-tief.csv",sep = ";")
head(data)
# Resumen estadístico de whisky
summary(data)
# Contar datos faltantes por variable
sum(is.na(data))
library(ggplot2)
library(tidyverse)
# 1. Distribución de Nacimientos y Muertes
ggplot(data, aes(x=geb)) + geom_histogram(bins=30, fill="blue", alpha=0.7) +
ggtitle("Distribución de Nacimientos") + xlab("Nacimientos") + ylab("Frecuencia")
ggplot(data, aes(x=tod)) + geom_histogram(bins=30, fill="red", alpha=0.7) +
ggtitle("Distribución de Muertes") + xlab("Muertes") + ylab("Frecuencia")
# 2. Distribución de la Población Total
ggplot(data, aes(x=swb)) + geom_histogram(bins=30, fill="green", alpha=0.7) +
ggtitle("Distribución de la Población Total") + xlab("Población Total") + ylab("Frecuencia")
# 3. Distribución por Edad
ggplot(data, aes(x=alter)) + geom_histogram(bins=30, fill="orange", alpha=0.7) +
ggtitle("Distribución por Edad") + xlab("Edad") + ylab("Frecuencia")
# 4. Boxplot por Municipio para Población Total
ggplot(data, aes(x=gemeinde, y=swb)) + geom_boxplot() +
ggtitle("Boxplot de Población Total por Municipio") + xlab("Municipio") + ylab("Población Total") +
theme(axis.text.x = element_text(angle = 90, hjust = 1))
# 4. Boxplot por Municipio para Población Total
ggplot(data, aes(x=gemeinde, y=swb)) + geom_boxplot() +
ggtitle("Boxplot de Población Total por Municipio") + xlab("Municipio") + ylab("Población Total") +
theme(axis.text.x = element_text(angle = 90, hjust = 1))
# 1. Distribución de Nacimientos y Muertes
ggplot(data, aes(x=geb)) + geom_histogram(bins=30, fill="blue", alpha=0.7) +
ggtitle("Distribución de Nacimientos") + xlab("Nacimientos") + ylab("Frecuencia")
ggplot(data, aes(x=tod)) + geom_histogram(bins=30, fill="red", alpha=0.7) +
ggtitle("Distribución de Muertes") + xlab("Muertes") + ylab("Frecuencia")
# 2. Distribución de la Población Total
ggplot(data, aes(x=swb)) + geom_histogram(bins=30, fill="green", alpha=0.7) +
ggtitle("Distribución de la Población Total") + xlab("Población Total") + ylab("Frecuencia")
# 3. Distribución por Edad
ggplot(data, aes(x=alter)) + geom_histogram(bins=30, fill="orange", alpha=0.7) +
ggtitle("Distribución por Edad") + xlab("Edad") + ylab("Frecuencia")
# Distribuciones de cómo la migración y la inmigración afectan los números de población.
# Histograma para 'ws'
ggplot(data, aes(x=ws)) + geom_histogram(binwidth = 1, fill="blue", alpha=0.7) +
ggtitle("Cambio en la población debido a movimientos espaciales") +
xlab("Movimientos Espaciales") + ylab("Frecuencia")
# Histograma para 'ein'
ggplot(data, aes(x=ein)) + geom_histogram(binwidth = 1, fill="green", alpha=0.7) +
ggtitle("Inmigración durante el año") +
xlab("Inmigración") + ylab("Frecuencia")
# Scatter Plot para 'swb' vs 'ein'
ggplot(data, aes(x=swb, y=ein)) + geom_point(alpha=0.6) +
ggtitle("Población al Final del Año vs Inmigración") +
xlab("Población al Final del Año") + ylab("Inmigración")
library(readr)
data <- read_csv("szbv-lu-2020-2050-tief.csv", locale = locale(encoding = "ISO-8859-1"), delim = ";")
head(data)
clear
data <- read_csv("szbv-lu-2020-2050-tief.csv", locale = locale(encoding = "ISO-8859-1"), delim = ";")
data <- read.csv("szbv-lu-2020-2050-tief.csv", sep = ";")
data <- read.csv("szbv-lu-2020-2050-tief.csv", locale = locale(encoding = "ISO-8859-1"), sep = ";")
data <- read.csv("szbv-lu-2020-2050-tief.csv", sep = ";")
head(data)
# Scatter Plot para 'swb' vs 'ein'
ggplot(data, aes(x=swb, y=ein)) + geom_point(alpha=0.6) +
ggtitle("Población al Final del Año vs Inmigración") +
xlab("Población al Final del Año") + ylab("Inmigración")
# Scatter Plot para 'swb' vs 'ws'
ggplot(data, aes(x=swb, y=ws)) + geom_point(alpha=0.6, color="red") +
ggtitle("Población al Final del Año vs Cambio por Movimientos Espaciales") +
xlab("Población al Final del Año") + ylab("Movimientos Espaciales")
# 1. Distribución de Nacimientos y Muertes
ggplot(data, aes(x=geb)) + geom_histogram(bins=30, fill="blue", alpha=0.7) +
ggtitle("Distribución de Nacimientos") + xlab("Nacimientos") + ylab("Frecuencia")
ggplot(data, aes(x=tod)) + geom_histogram(bins=30, fill="red", alpha=0.7) +
ggtitle("Distribución de Muertes") + xlab("Muertes") + ylab("Frecuencia")
# 2. Distribución de la Población Total
ggplot(data, aes(x=swb)) + geom_histogram(bins=30, fill="green", alpha=0.7) +
ggtitle("Distribución de la Población Total") + xlab("Población Total") + ylab("Frecuencia")
# 3. Distribución por Edad
ggplot(data, aes(x=alter)) + geom_histogram(bins=30, fill="orange", alpha=0.7) +
ggtitle("Distribución por Edad") + xlab("Edad") + ylab("Frecuencia")
# 3. Distribución por Edad
ggplot(data, aes(x=alter)) + geom_histogram(bins=30, fill="orange", alpha=0.7) +
ggtitle("Distribución por Edad") + xlab("Edad") + ylab("Frecuencia")
# Distribuciones de cómo la migración y la inmigración afectan los números de población.
# Histograma para 'ws'
ggplot(data, aes(x=ws)) + geom_histogram(binwidth = 1, fill="blue", alpha=0.7) +
ggtitle("Cambio en la población debido a movimientos espaciales") +
xlab("Movimientos Espaciales") + ylab("Frecuencia")
# Histograma para 'ein'
ggplot(data, aes(x=ein)) + geom_histogram(binwidth = 1, fill="green", alpha=0.7) +
ggtitle("Inmigración durante el año") +
xlab("Inmigración") + ylab("Frecuencia")
# EDA Multivariado
# Calculando la matriz de correlación para las variables numéricas
numeric_vars <- data[, sapply(data, is.numeric)]  # seleccionar solo las variables numéricas
cor_matrix <- cor(numeric_vars, use = "complete.obs")  # usar 'complete.obs' para manejar NA
print(cor_matrix)
cor_matrix
# EDA Multivariado
# Calculando la matriz de correlación para las variables numéricas
numeric_vars <- data[, sapply(data, is.numeric)]  # seleccionar solo las variables numéricas
cor_matrix <- cor(numeric_vars, use = "complete.obs")  # usar 'complete.obs' para manejar NA
cor_matrix
cor_matrix <- cor(data)  # usar 'complete.obs' para manejar NA
# Tabla de contingencia para sexo y nacionalidad
sex_nation_table <- table(data$sex, data$nation)
print(sex_nation_table)
# Tabla de contingencia para sexo y nacionalidad
sex_nation_table <- table(data$sex, data$nation)
sex_nation_table
ggplot(data, aes(x = swb, y = ein)) +
geom_point(alpha = 0.6) +
ggtitle("Relación entre Inmigración y Población al Final del Año") +
xlab("Población al Final del Año") +
ylab("Inmigración")
# EDA Multivariado
# Calculando la matriz de correlación para las variables numéricas
numeric_vars <- data[, sapply(data, is.numeric)]  # seleccionar solo las variables numéricas
cor_matrix <- cor(numeric_vars)
print(cor_matrix)
# EDA Multivariado
# Calculando la matriz de correlación para las variables numéricas
numeric_vars <- data[, sapply(data, is.numeric)]  # seleccionar solo las variables numéricas
# EDA Multivariado
# Calculando la matriz de correlación para las variables numéricas
numeric_vars <- data[, sapply(data, is.numeric)]  # seleccionar solo las variables numéricas
cor_matrix <- cor(numeric_vars)
print(cor_matrix)
cor_matrix
# Tabla de contingencia para sexo y nacionalidad
sex_nation_table <- table(data$sex, data$nation)
sex_nation_table
# Gráfico de dispersión para inmigración vs. población al final del año
ggplot(data, aes(x = swb, y = ein)) +
geom_point(alpha = 0.6) +
ggtitle("Relación entre Inmigración y Población al Final del Año") +
xlab("Población al Final del Año") +
ylab("Inmigración")
# Gráfico de dispersión para nacimientos vs. movimientos espaciales
ggplot(data, aes(x = ws, y = geb)) +
geom_point(alpha = 0.6, color = "blue") +
ggtitle("Relación entre Nacimientos y Movimientos Espaciales") +
xlab("Movimientos Espaciales") +
ylab("Nacimientos")
library(ggplot2)
library(tidyverse)
library(corrplot)
library(FactoMineR)
library(factoextra)
corrplot(cor_matrix, method = "circle")
library(lawstat)
# Aplicación del Análisis de Componentes Principales
ACP <- PCA(numeric_vars, ncp=5, scale.unit=TRUE)
ACP
# Aplicación de clasificación jerárquica sobre los resultados del PCA
Cong <- HCPC(ACP, nb.clust=-1)  # nb.clust=-1 significa que determinará automáticamente el número de clusters
Cong
# Aplicación de clasificación jerárquica sobre los resultados del PCA
Cong <- HCPC(ACP, nb.clust=-1)  # nb.clust=-1 significa que determinará automáticamente el número de clusters
# Aplicación de clasificación jerárquica sobre los resultados del PCA
Cong <- HCPC(ACP)  # nb.clust=-1 significa que determinará automáticamente el número de clusters
# Aplicación del Análisis de Componentes Principales
ACP <- PCA(numeric_vars, ncp=2, scale.unit=TRUE)
# Aplicación del Análisis de Componentes Principales
set.seed(123) # Fijar la semilla para reproducibilidad
data_sample <- numeric_vars[sample(nrow(numeric_vars), 10000), ]
# Escalar las variables antes de aplicar PCA para que todas tengan la misma importancia
data_sample_scaled <- scale(data_sample)
# Aplicar PCA
res.pca <- PCA(data_sample_scaled, ncp = 5, graph = FALSE)
# Aplicar PCA
res.pca <- PCA(data_sample_scaled, ncp = 5)
data_sample <- numeric_vars[sample(nrow(numeric_vars), 10000), ]
# Aplicar PCA
res.pca <- PCA(data_sample, ncp = 5)
# Ver resultados del PCA
print(res.pca)
# Visualizar los resultados del PCA: Gráfico de varianza explicada
fviz_eig(res.pca)
# Visualización del biplot de individuos y variables
fviz_pca_biplot(res.pca, repel = TRUE)
# Para la clasificación jerárquica, primero determinamos el número óptimo de clusters
fviz_nbclust(data_sample, FUN = hcut, method = "wss")
# Ejecutar la clasificación jerárquica
set.seed(123)
res.hcpc <- HCPC(res.pca, nb.clust = -1, graph = FALSE)  # nb.clust = -1 determina el número automáticamente
# Ver resultados de la clasificación jerárquica
res.hcpc
# Visualizar los clusters
fviz_cluster(res.hcpc, data = data_sample)
levene.test(ACP$ind$coord[,1], as.factor(res.hcpc$data.clust$clust))
# Realizar ANOVA para comparar las medias de los clusters
fit <- aov(ACP$ind$coord[,1] ~ as.factor(res.hcpc$data.clust$clust))
anova(fit)
# Aplicación del Análisis de Componentes Principales
set.seed(123) # Fijar la semilla para reproducibilidad
data_sample <- numeric_vars[sample(nrow(numeric_vars), 10000), ]
# Aplicar PCA
res.pca <- PCA(data_sample, ncp = 5, scale.unit=TRUE)
# Ver resultados del PCA
res.pca
# Visualizar los resultados del PCA: Gráfico de varianza explicada
fviz_eig(res.pca)
# Visualización del biplot de individuos y variables
fviz_pca_biplot(res.pca, repel = TRUE)
# Para la clasificación jerárquica, primero determinamos el número óptimo de clusters
fviz_nbclust(data_sample, FUN = hcut, method = "wss")
# Ejecutar la clasificación jerárquica
res.hcpc <- HCPC(res.pca, nb.clust = -1, graph = FALSE)  # nb.clust = -1 determina el número automáticamente
# Ver resultados de la clasificación jerárquica
res.hcpc
# Visualizar los clusters
fviz_cluster(res.hcpc, data = data_sample)
# MCA
# Asegurándonos de que solo estamos usando las variables categóricas
data_categorical <- data[, sapply(data, is.factor)]
# Aplicar MCA a las variables categóricas
res.mca <- MCA(data_categorical, ncp = 5, graph = FALSE)
# MCA
# Asegurándonos de que solo estamos usando las variables categóricas
data_categorical <- data[, sapply(data, is.factor)]
# Aplicar MCA a las variables categóricas
res.mca <- MCA(data_categorical, ncp = 5, graph = FALSE)
# MCA
# Asegúrate de que todas las variables categóricas sean de tipo factor
data_categorical <- data[, sapply(data, function(x) is.factor(x) || is.character(x))]
data_categorical <- lapply(data_categorical, factor)  # Convierte todas las variables categóricas a factores
# Aplicar MCA a las variables categóricas
res.mca <- MCA(data_categorical, ncp = 5, graph = FALSE)
# Ver los resultados del MCA
print(res.mca)
data <- read.csv("szbv-lu-2020-2050-tief.csv", sep = ";")
# MCA
# Asegúrate de que todas las variables categóricas sean de tipo factor
data_categorical <- data[, sapply(data, function(x) is.factor(x) || is.character(x))]
data_categorical <- lapply(data_categorical, factor)  # Convierte todas las variables categóricas a factores
# Aplicar MCA a las variables categóricas
res.mca <- MCA(data_categorical, ncp = 5, graph = FALSE)
# Ver los resultados del MCA
print(res.mca)
data_categorical
# MCA
# Asegúrate de que todas las variables categóricas sean de tipo factor
categorical_columns <- sapply(data, function(x) is.factor(x) || is.character(x))
# Nos aseguramos de que al menos una columna sea seleccionada
if (sum(categorical_columns) == 0) {
stop("No hay variables categóricas para realizar el MCA.")
}
# Seleccionamos solo las columnas categóricas
data_categorical <- data[, categorical_columns]
data_categorical <- data.frame(lapply(data_categorical, factor))  # Convertimos a factores
# Verificamos que el dataframe no esté vacío
if (nrow(data_categorical) == 0) {
stop("El conjunto de datos resultante está vacío.")
}
# Aplicamos MCA a las variables categóricas
res.mca <- MCA(data_categorical, ncp = 5, graph = FALSE)
# Visualizamos los resultados del MCA
print(res.mca)
data <- read.csv("szbv-lu-2020-2050-tief.csv", sep = ";")
head(data)
# Aplicamos MCA a las variables categóricas
res.mca <- MCA(data_categorical, ncp = 5)
# Visualización de la inercia de las dimensiones (Scree plot)
fviz_screeplot(res.mca) +
geom_hline(yintercept = max.porc, linetype = 2, color = "red") +
labs(title = "Scree plot", x = "Dimensions", y = "Percentage of variance")
# Visualización de las variables en el mapa de factores
fviz_mca_var(res.mca, col.var = "contrib",
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
repel = TRUE)
# Utilizando k-means para agrupar los individuos basados en sus coordenadas de MCA
set.seed(123) # Fijar semilla para reproducibilidad
kmMCA <- kmeans(res.mca$ind$coord, 3) # Agrupar en 3 clusters
# Visualización de los clusters
fviz_cluster(list(data = res.mca$ind$coord, cluster = kmMCA$cluster))
